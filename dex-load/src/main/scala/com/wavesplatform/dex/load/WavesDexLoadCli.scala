package com.wavesplatform.dex.load

import java.io.{EOFException, File}
import java.util.Scanner

import cats.syntax.option._
import com.wavesplatform.dex.Version
import com.wavesplatform.dex.domain.account.AddressScheme
import scopt.{OParser, RenderingMode}

import scala.concurrent.{Future, Promise}

object WavesDexLoadCli {
  def main(rawArgs: Array[String]): Unit = {
    val builder = OParser.builder[Args]

    val parser = {
      import builder._
      OParser.sequence(
        programName("dex-cli"),
        head("DEX CLI", Version.VersionString),
        opt[Char]("address-scheme")
          .abbr("as")
          .text("The network byte as char. By default it is the testnet: 'T'")
          .valueName("<one char>")
          .action((x, s) => s.copy(addressSchemeByte = x)),
        opt[File]("feeder-file")
          .abbr("ff")
          .text("Where to save/read the feeder data")
          .action((x, s) => s.copy(feederFile = x)),
        cmd(Command.CreateFeederFile.name)
          .action((_, s) => s.copy(command = Command.CreateFeederFile.some))
          .text("Creates files for Gatling feeder")
          children (
            opt[Int]("accounts-number")
              .abbr("an")
              .text("The number of generated accounts")
              .required()
              .action((x, s) => s.copy(accountsNumber = x)),
            opt[String]("raw-seed-prefix")
              .abbr("rsp")
              .text("The raw seed prefix. Each account generated by formula: seedPrefix + accountNumber")
              .action((x, s) => s.copy(seedPrefix = x)),
            opt[File]("pairs-file")
              .abbr("pf")
              .text("The path to the file with asset pairs. The format: one asset pair per line")
              .required()
              .action((x, s) => s.copy(pairsFile = x.some)),
            opt[Int]("order-book-number-per-account")
              .abbr("obnpa")
              .text("The number of subscribed order book per account. Must be less than number of asset pairs in pairs-file")
              .required()
              .action((x, s) => s.copy(orderBookNumberPerAccount = x))
        ),
        cmd(Command.Check.name)
          .action((_, s) => s.copy(command = Command.Check.some))
          .text("Creates files for Gatling check")
          .children(
            opt[String]("api-uri")
              .abbr("au")
              .text("The URI to the WebSocket API, e.g.: wss://localhost/ws/v0")
              .required()
              .action((x, s) => s.copy(apiUri = x))
          ),
        cmd(Command.CreateRequests.name)
          .action((_, s) => s.copy(command = Command.CreateRequests.some))
          .text("Creates file with requests for yandex-tank")
          .children(
            opt[String]("environment-settings")
              .abbr("es")
              .text("The file with environment settings")
              .required()
              .action((x, s) => s.copy(apiUri = x))
          )
      )
    }

    OParser.parse(parser, rawArgs, Args()).foreach { args =>
      args.command match {
        case None => println(OParser.usage(parser, RenderingMode.TwoColumns))
        case Some(command) =>
          println(s"Running '${command.name}' command")
          AddressScheme.current = new AddressScheme {
            override val chainId: Byte = args.addressSchemeByte.toByte
          }
          command match {
            case Command.CreateRequests =>
              TankGenerator.mkRequests(args.seedPrefix, args.environmentSettings)
            case Command.CreateFeederFile =>
              GatlingFeeder.mkFile(args.accountsNumber, args.seedPrefix, args.pairsFile.get, args.orderBookNumberPerAccount, args.feederFile)
            case Command.Check =>
              val (inputConnected, stop) = waitForInput()
              if (inputConnected) GatlingChecker.check(args.apiUri, args.inputData, stop)
              else println("End of input. Try terminal")
          }
          println("Done")
      }
    }
  }

  private sealed trait Command {
    def name: String
  }

  private object Command {

    case object CreateFeederFile extends Command {
      override def name: String = "create-feeder-file"
    }

    case object Check extends Command {
      override def name: String = "check"
    }

    case object CreateRequests extends Command {
      override def name: String = "create-requests"
    }
  }

  private val defaultFeederFile = new File("feeder.csv")

  private case class Args(addressSchemeByte: Char = 'T',
                          command: Option[Command] = None,
                          feederFile: File = defaultFeederFile,
                          inputData: File = defaultFeederFile,
                          pairsFile: Option[File] = None,
                          accountsNumber: Int = 1000,
                          seedPrefix: String = "loadtest-",
                          orderBookNumberPerAccount: Int = 10,
                          environmentSettings: String = "devnet.conf",
                          apiUri: String = "")

  private def waitForInput(): (Boolean, Future[Unit]) = {
    val expectedInput = "stop"

    val scanner = new Scanner(System.in)
    val p       = Promise[Unit]()

    @scala.annotation.tailrec
    def loop(): Boolean = {
      println(s"Enter '$expectedInput' (without quotes) to stop: ")
      val hasNext = scanner.hasNextLine
      if (hasNext) {
        if (scanner.nextLine() == expectedInput) {
          p.success(())
          true
        } else loop()
      } else {
        p.failure(new EOFException())
        false
      }
    }

    (loop(), p.future)
  }

}
