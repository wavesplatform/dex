package com.wavesplatform.dex.load

import java.io.File
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.util.concurrent.Executors

import akka.actor.ActorSystem
import cats.syntax.either._
import cats.syntax.option._
import com.softwaremill.diffx._
import com.wavesplatform.dex.Version
import com.wavesplatform.dex.api.websockets.{WsAddressState, WsOrderBook}
import com.wavesplatform.dex.cli.ScoptImplicits
import com.wavesplatform.dex.domain.account.AddressScheme
import com.wavesplatform.dex.domain.bytes.ByteStr
import scopt.{OParser, RenderingMode}

import scala.concurrent.duration.{DurationInt, FiniteDuration}
import scala.concurrent.{Await, ExecutionContext, Future}

object WavesDexLoadCli extends ScoptImplicits {
  def main(rawArgs: Array[String]): Unit = {
    val executor        = Executors.newCachedThreadPool()
    implicit val global = ExecutionContext.fromExecutor(executor)

    val builder = OParser.builder[Args]

    val parser = {
      import builder._
      OParser.sequence(
        programName("dex-cli"),
        head("DEX CLI", Version.VersionString),
        opt[Char]("address-scheme")
          .abbr("as")
          .text("The network byte as char. By default it is the testnet: 'T'")
          .valueName("<one char>")
          .action((x, s) => s.copy(addressSchemeByte = x)),
        opt[File]("feeder-file")
          .abbr("ff")
          .text("Where to save/read the feeder data")
          .action((x, s) => s.copy(feederFile = x)),
        cmd(Command.CreateFeederFile.name)
          .action((_, s) => s.copy(command = Command.CreateFeederFile.some))
          .text("Creates files for Gatling feeder")
          children (
            opt[Int]("accounts-number")
              .abbr("an")
              .text("The number of generated accounts")
              .required()
              .action((x, s) => s.copy(accountsNumber = x)),
            opt[String]("raw-seed-prefix")
              .abbr("rsp")
              .text("The raw seed prefix. Each account generated by formula: seedPrefix + accountNumber")
              .action((x, s) => s.copy(seedPrefix = x)),
            opt[File]("pairs-file")
              .abbr("pf")
              .text("The path to the file with asset pairs. The format: one asset pair per line")
              .required()
              .action((x, s) => s.copy(pairsFile = x.some)),
            opt[Int]("order-book-number-per-account")
              .abbr("obnpa")
              .text("The number of subscribed order book per account. Must be less than number of asset pairs in pairs-file")
              .required()
              .action((x, s) => s.copy(orderBookNumberPerAccount = x)),
            opt[File]("auth-services-private-key-file")
              .abbr("aspkf")
              .text("The path to file with Auth Services' private key. The public key should be in the DEX's config")
              .required()
              .action((x, s) => s.copy(authServicesPrivateKeyFile = x))
        ),
        cmd(Command.Check.name)
          .action((_, s) => s.copy(command = Command.Check.some))
          .text("Runs multiple WebSocket consumers and then checks that all data was received")
          .children(
            opt[String]("dex-rest-api")
              .abbr("dra")
              .text("DEX REST API uri. Format: scheme://host:port (default scheme will be picked if none was specified)")
              .required()
              .action((x, s) => s.copy(dexRestApi = x)),
            opt[Int]("accounts-number")
              .abbr("an")
              .text("The number of checked accounts")
              .required()
              .action((x, s) => s.copy(accountsNumber = x)),
            opt[FiniteDuration]("collect-time")
              .abbr("ct")
              .text("The time to collect the data")
              .action((x, s) => s.copy(collectTime = x))
          ),
        cmd(Command.CreateRequests.name)
          .action((_, s) => s.copy(command = Command.CreateRequests.some))
          .text("Creates file with requests for yandex-tank")
          .children(
            opt[String]("environment-settings")
              .abbr("es")
              .text("The file with environment settings")
              .required()
              .action((x, s) => s.copy(dexRestApi = x))
          )
      )
    }

    try {
      OParser.parse(parser, rawArgs, Args()).foreach { args =>
        args.command match {
          case None => println(OParser.usage(parser, RenderingMode.TwoColumns))
          case Some(command) =>
            println(s"Running '${command.name}' command")
            AddressScheme.current = new AddressScheme {
              override val chainId: Byte = args.addressSchemeByte.toByte
            }
            println(s"Chain id: ${args.addressSchemeByte}")
            command match {
              case Command.CreateRequests =>
                TankGenerator.mkRequests(args.seedPrefix, args.environmentSettings)

              case Command.CreateFeederFile =>
                val authPrivateKey = new String(Files.readAllBytes(args.authServicesPrivateKeyFile.toPath), StandardCharsets.UTF_8)
                GatlingFeeder.mkFile(
                  accountsNumber = args.accountsNumber,
                  seedPrefix = args.seedPrefix,
                  authKp = GatlingFeeder.authServiceKeyPair(authPrivateKey),
                  pairsFile = args.pairsFile.get,
                  orderBookNumberPerAccount = args.orderBookNumberPerAccount,
                  feederFile = args.feederFile
                )

              case Command.Check =>
                implicit val system = ActorSystem()

                val wsApiUri = s"${prependScheme(args.dexRestApi, webSocket = true)}/ws/v0"
                println(s"Connecting to $wsApiUri...")

                val clients = WsAccumulateChanges.createClients(wsApiUri, args.feederFile, args.accountsNumber)
                try {
                  println("Stage 1. Running clients...")
                  Await.result(Future.traverse(clients)(_.run()), 30.seconds)

                  Thread.sleep(args.collectTime.toMillis)

                  println("Stage 1. Getting collected data...")

                  val watchedAddresses  = getOrExit(checkUniq(clients.map(_.collectedAddressState).groupBy(_.address)))
                  val watchedOrderBooks = getOrExit(checkUniq(switch(clients.map(_.collectedOrderBooks))))

                  println("Stage 1. Stopping clients...")
                  clients.foreach(_.close())

                  println("Stage 2. Running clients...")
                  Await.result(Future.traverse(clients)(_.run()), 30.seconds)
                  Thread.sleep(args.wsResponseWaitTime.toMillis)

                  println("Stage 2. Getting collected data...")
                  val finalAddresses  = getOrExit(checkUniq(clients.map(_.collectedAddressState).groupBy(_.address)))
                  val finalOrderBooks = getOrExit(checkUniq(switch(clients.map(_.collectedOrderBooks))))

                  println("Stage 3. Stopping clients...")
                  clients.foreach(_.close())

                  println("Running checks...")
                  val addressesCompareResult = compare(watchedAddresses, finalAddresses)
                  if (addressesCompareResult.isIdentical) println("Addresses are same")
                  else println(s"Found issues:\n${addressesCompareResult.show}")

                  val orderBooksCompareResult = compare(watchedOrderBooks, finalOrderBooks)
                  if (orderBooksCompareResult.isIdentical) println("Order books are same")
                  else println(s"Found issues:\n${orderBooksCompareResult.show}")

                  println("All is ok")
                } finally {
                  clients.foreach(_.close())
                  system.terminate()
                }
            }
            println("Done")
        }
      }
    } finally executor.shutdownNow()
  }

  private sealed trait Command {
    def name: String
  }

  private object Command {

    case object CreateFeederFile extends Command {
      override def name: String = "create-feeder-file"
    }

    case object Check extends Command {
      override def name: String = "check"
    }

    case object CreateRequests extends Command {
      override def name: String = "create-requests"
    }
  }

  private val defaultFeederFile = new File("feeder.csv")

  private case class Args(addressSchemeByte: Char = 'T',
                          command: Option[Command] = None,
                          authServicesPrivateKeyFile: File = defaultFeederFile,
                          feederFile: File = defaultFeederFile,
                          pairsFile: Option[File] = None,
                          accountsNumber: Int = 1000,
                          seedPrefix: String = "loadtest-",
                          orderBookNumberPerAccount: Int = 10,
                          environmentSettings: String = "devnet.conf",
                          dexRestApi: String = "",
                          collectTime: FiniteDuration = 5.seconds,
                          wsResponseWaitTime: FiniteDuration = 5.seconds)

  private def prependScheme(uri: String, webSocket: Boolean = false): String = {
    val (plain, secure) = if (webSocket) "ws://" -> "wss://" else "http://" -> "https://"
    if (uri.startsWith(secure) || uri.startsWith(plain)) uri else plain + uri
  }

  private def getOrExit[K, V](from: Either[Map[K, Seq[DiffResult]], Map[K, V]]): Map[K, V] = from match {
    case Right(x) => x
    case Left(xs) =>
      xs.foreach { case (k, issues) => println(s"Found issues in $k:\n${issues.map(_.show).mkString("\n")}") }
      sys.exit(1)
  }

  private def checkUniq[K, V: Diff](xs: Map[K, Seq[V]]): Either[Map[K, Seq[DiffResult]], Map[K, V]] = {
    val notIdentical = xs
      .filter(_._2.length > 1)
      .map {
        case (k, group) =>
          val first        = group.head
          val notIdentical = group.tail.map(compare(first, _)).filterNot(_.isIdentical)
          k -> notIdentical
      }
      .filter(_._2.nonEmpty)
    if (notIdentical.isEmpty) xs.collect { case (k, xs) if xs.nonEmpty => k -> xs.head }.asRight
    else notIdentical.asLeft
  }

  private def switch[K, V](xs: Seq[Map[K, V]]): Map[K, Seq[V]] = xs.foldLeft(Map.empty[K, List[V]]) {
    case (r, x) => x.foldLeft(r) { case (r, (k, v)) => r.updated(k, v :: r.getOrElse(k, List.empty)) }
  }

  private implicit val derivedByteStrDiff: Derived[Diff[ByteStr]] = Derived(getDiff[ByteStr](_.toString == _.toString))
  private implicit val wsAddressStateDiff: Diff[WsAddressState]   = Derived[Diff[WsAddressState]].ignore(_.timestamp).ignore(_.updateId)
  private implicit val wsOrderBookDiff: Diff[WsOrderBook]         = Derived[Diff[WsOrderBook]].ignore(_.timestamp).ignore(_.updateId)

  private def getDiff[T](comparison: (T, T) => Boolean): Diff[T] = { (left: T, right: T, _: List[FieldPath]) =>
    if (comparison(left, right)) Identical(left) else DiffResultValue(left, right)
  }
}
